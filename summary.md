# 算法训练营

## 第一周课程

### 数据结构

- 一维

	- 基础

		- 数组 array (string)

			- 时间复杂度

				- prepend:O(1)
				- append:O(1)
				- lookup:O(1)
				- insert:O(n)
				- delete:O(n)

		- 链表 linked list

			- 时间复杂度

				- prepend:O(1)
				- append:O(1)
				- lookup:O(n)
				- insert:O(1)
				- delete:O(1)

			- 跳表

	- 高级

		- 栈 stack
		- 队列 queue
		- 双端队列 deque
		- 集合 set
		- 映射 map (hash or map)

- 二维

	- 基础

		- 树 tree
		- 图 graph

	- 高级

		- 二叉搜索树 binary search tree (red-black tree, AVL)
		- 堆 heap
		- 并查集 disjoint set
		- 字典树 Trie

- 特殊

	- LRU Cache
	-  布隆过滤器 BloomFilter
	- 位运算 Bitwise

### 算法

- If-else, switch —> branch(跳转语句,表示逻辑的切换)
- for, while loop —> Iteration(循环,for loop 也可以写成 which)
- 递归 Recursion (Divide & Conquer分治, Backtrace回溯)
- 搜索 Search:

	- 深度优先搜索 Depth first search
	- 广度优先搜索 Breadth first search
	- A*

- 动态规划 Dynamic Programming
- 二分查找 Binary Search
- 贪心 Greedy
- 数学 Math , 几何 Geometry

### 对个体：切题四件套

- Clarification :多看题，理解题意，沟通确认
- Possible solutions:

	- 想尽可能多的解法
	-  compare (time/space) 比较每一种解法的时间/空间复杂度
	- optimal(加强) 最佳的

-  Coding(多写): 写代码
- Test cases: 写完之后把测

### 对全部：五遍刷题法(五毒神掌)

- 刷题第一遍：5分钟:读题 + 思考


	- 直接看解法:注意!多解法，比较解法优劣(注意:算法本身是要理解和运用,而不是自己去发明和创造.所以这里在没有解题思路的情况下,直接看别人的解法并比较不同解法的优劣;如果有思路,就是上面的"切题四件套"了)
	- 背诵、默写好的解法: 背诵和默写很重要,记忆之后一般百分百能理解,但是可能需要反复很多遍之后!

- 刷题第二遍：马上自己写

	- LeetCode 提交: 反复修改,直到是"通过"的状态.
	- 多种解法比较、体会 —> 优化!

- 刷题第三遍

	- 一天后，再重复做题
	- 不同解法的熟练程度 

		- 专项练习: 针对不熟的题目或者不熟的解法

- 刷题第四遍

	- 一周后反复回来练习相同题目
	- 不同解法的熟练程度 

		- 专项练习: 针对不熟的题目或者不熟的解法

- 刷题第五遍

	- 面试前一周恢复性训练

## 第二周课程

### 哈希表

### 映射

### 集合

### 树、二叉树

- 二叉树的遍历（前序\中序\后序遍历）

	- 前序遍历(pre_order)：根->左->右
	- 中序遍历(in_order)：左->根->右
	- 后序遍历(post_order)：左->右->根
	- 层次遍历：只需按层次遍历即可

- 树的面试题解法一般都是递归，为什么？

	- 1、节点及其本身的定义就是用递归的方式来进行的
	- 2、重复性(自相似性)

- 完全二叉树
- 链表就是特殊的树
- 树是特殊的图(没有环的图)

### 二叉搜索树

- 空树也是二叉树
- 左子树上所有节点均小于根节点
- 右子树上所有节点均大于根节点
- 左右子树也分别是二叉查找树
- 中序遍历
- 时间复杂度log(2n)
- 删除节点

	- 节点为叶子节点直接删除
	- 节点为根节点取右子树里最小节点(也就是第一个节点)

- 题：二叉树中序遍历

	- 递归解法

	- 迭代解法（典型 深度优先搜索（DFS） 模式，深度优先搜索改成 迭代循环 写法通常需借助 栈 来手动控制）

### 堆、二叉堆、图

### 其他

- MSB(Most Significant Bit)最高有效位
- LSB( least significant bit)最低有效位
- https://www.bilibili.com/video/BV1wp4y1X768
- &与：两个同时为1，结果为1
- |或：一个为1，其值为1
- ^异或：值不同为1；否则为0
- DFS(深度优先搜索)层遍历

## 第三周课程

### 递归

- 思维要点

	- 1、不要人肉递归(最大误区)
	- 找到最近最简方法，将其拆解成功可重复子问题

		- Why：程序指令只包括if else/for/while loop以及递归调用

	- 数学归纳法思维

- 模板

	- recursion terminator 递归终止条件及return
	- process处理当前逻辑
	- drill down下探到下一层(level、参数)
	- reverse states清扫当前层

### BST

- 中序遍历是递增的

### 分治

### 回溯


## 第四周课程

### 搜索-遍历

- 每个节点都要访问一次
- 每个节点仅仅要访问一次
- 访问顺序不限

	- 深度优先搜索Depth first search

	- 广度优先搜索Breadth first search

		- 层序遍历、最短路径

### 贪心算法

- 每一步选择中都采取在当前状态下最好或最优的选择，从而希望导致结果是全局最好或者最优算法

### 比较

- 贪心算法

	- 当下做局部最优判断，不能回退

		- 求最优
		- 求最好
		- 求最近

- 回溯

	- 能够回退

- 动态规划

	- 保存之前结果，以对当前做最优判断，可回退

### 二分查找

- 前提

	- 1、目标函数单调性
	- 2、存在上下界bounded
	- 3、可通过索引访问

## 第五周课程

### 动态规划

- 动态规划、递归、分治无本质区别，关键看有无最优子结构
- 共性：找到重复子问题
- 差异性：最优子结构、中途可淘汰次优解
- 关键点

	- 1、最优子结构:opt[n] = best_of(opt[n-1],opt[n-2],...)
	- 2、存储中间状态：opt[i]
	- 3、递推公式(状态转移/DP方程)

		- fib:opt[i] =opt[n-1]+opt[n-2]
		- 二维路径:opt[i,j]=opt[i+1][j]+opt[i][j+1](且判断a[i][j]是否为空地)
## 第六周

### 字典树trie

- 1、数据结构
- 2、核心思想
- 3、基本性质

	- 1.结点本身不存完整单词;
	- 2.从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串;
	- 3.每个结点的所有子结点路径代表的字符都不相同。

*XMind: ZEN - Trial Version*